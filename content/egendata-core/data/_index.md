---
title: Data
---

All communication between the different Egendata parties is performed through signed messages shaped as JWT:s.

[Message definitions](./messages)

## Data structures & storage

- The user’s data is stored in json format.
- No data structure has been defined for the user’s data. It instead keeps the tags of the form it was generated in as the field names. This means that the service dictates the structure of the data that is generated and consumed by it, as well as stored in the PDS.
- The only data stored in the operator is the database records of (registered) users, services, their connections and consents given. This database schema is set up by the scripts in the “migrations” folder of the operator. One of those scripts generates a table called “pgmigrations” that holds the information about when and how (successfully or not) the other tables were generated.
- The account data is stored in the operator in a postgres database.
- Information stored (keys and cached permissions) on the user’s phone is stored in the sync local storage of the device.
- In the current implementation of Egendata, when the user selects to store their data in memory, the data is stored in the internal memory of the operator. This includes and is limited to the data generated by the user in the different services.

## Step-by-step for data generation

### Registering of a service

The following messages are required to establish a service as registered:

- `SERVICE_REGISTRATION` sends a message containing the information describing the service.
- `LAWFUL_BASIS` contains information about the reason the service requires to read the data from the user.
- `PERMISSION_BASE` contains information about the reason the service will request permission to the different areas of the user’s profile.

### Registering a user

When a user is registering the following information is being generated and sent to the operator:

- `ACCOUNT_REGISTRATION` the user’s device generates a unique id and sends it, as part of the message, to the operator, who prefixes it to the account.

### Logging in to a service with Egendata

In this step we need to consider if the user has an already established connection or not with the service they are trying to log in to. In both cases the process starts by scanning the QR  code of the service with the user’s device. After the QR code is scanned and until the following steps are completed the browser that housed the QR code starts polling the Operator for an `ACCESS_TOKEN`.

#### With an established connection

In this case, the user’s device recognizes that there is an existing connection with this service stored in the App’s internal cache and the following messages are triggered:

1. A `LOGIN_RESPONSE` containing a serialized JWS `LOGIN` as payload is sent to the operator. This `LOGIN_RESPONSE` contains the user’s ID as the subject(iss?), and the service as a string in the body(within the `LOGIN`).
1. The operator extracts the `LOGIN` from the `LOGIN_RESPONSE` a wraps it in a new  `LOGIN_EVENT` message and forwards the message to the service. This happens so the service doesn’t get access to the user’s ID.

#### Without an established connection

If this user’s device does not recognize the service then the following messages are triggered:

1. A `CONNECTION_INIT` is sent from the user’s device directly to the service’s `/events` endpoint.
1. The service responds with a `CONNECTION_REQUEST` to the user’s device.
1. The `CONNECTION_REQUEST` might optionally contain a `PERMISSION_REQUEST_ARRAY` detailing all the areas it is requesting access from the user’s profile.
1. If the `PERMISSION_REQUEST_ARRAY` is missing, at the moment, there is no way to send this in a later stage in the communication. There is no error handling for this eventuality and it will result in the system not working, because it will find a null string where it is expecting a not null string.
1. Each `PERMISSION_REQUEST` in the `PERMISSION_REQUEST_ARRAY` contains a `LAWFUL_BASIS`. In the current implementation this is defaulted to consent unless specified otherwise.
1. For read permissions the read key is sent alongside the permission, in the form of `kid` (key id).
1. The description of a write permission could be the schema that needs to be followed. Although, this is not implemented.
1. The key used in the write permissions is the public key derived by the private key sent through a read permission. Instead the path to the jwks is attached. The jwks contains the public keys of the user and the service, that are needed to read and write stuff.
1. After receiving the `CONNECTION_REQUEST` the device generates a `CONNECTION` wrapped in a `CONNECTION_RESPONSE` that is sent to the operator.
1. The operator upon receiving the `CONNECTION_RESPONSE` extracts from it the `CONNECTION` and rewraps it in a `CONNECTION_EVENT` that is sent to the service.

## Reading data from PDS

For this process the operator accesses the user’s pds and reads the data requested by the service, as defined by the domain and area sent in though a `DATA_READ_REQUEST`. This means that a service could request data from other services by including another service’s domain in the `DATA_READ_REQUEST` message.
The requested data is sent to the service by the operator with a `DATA_READ_RESPONSE`.

{{% notice tip %}}
Currently only Dropbox is supported as a PDS. It is, however, called through an abstraction which treats it as `fs`. This means that as long as another PDS can be called through the same abstraction, it is simple to implement.
{{% /notice %}}

- The domain defined in the request in the services ID, which is the URI of the service.
- The areas that are defined in the request are the different areas of the CV.
- The response to the request is sent with a DATA_READ_RESPONSE message for each path requested. This means that for each domain and area path that has been requested the data stored in that folder is sent to the service separately.
- These responses are sent encrypted and then decrypted by the client library.

## Writing data to a PDS

For this process the domain, area and data that needs to be written are sent with a `DATA_WRITE` message, from the service to the operator.
The data are encrypted before being sent to the operator, and then written to the PDS.
If there is a permission for writing to the user’s PDS the operator writes the data to the PDS. If there is no such permission.
Since all of the data are handled with one message, if even one of the areas is missing a write permission, the operation fails and the data is discarded.

